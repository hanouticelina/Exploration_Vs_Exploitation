import random as rd
import numpy as np
epsilon = 0.1
# 
def jouer(machine, action):
    p = rd.uniform(0,1)
    if p <= machine[action] :
        return 1
    return 0

def algoAlea(gains,nb):
    return rd.randint(0,len(gains)-1)

def algoGreedy(gains, nb):
    return np.argmax(gains)

def algoEpsGreedy(gains, nb):
    if rd.random() < epsilon:
        return algoAlea(gains, nb)
    return algoGreedy(gains, nb)

def algoUCB(gains, nb):
    if(np.min(nb) == 0):
        return np.argmin(nb)
    t = np.sum(nb)
    L = gains + np.sqrt((2*np.log(t))/nb)
    return np.argmax(L)
        
def run(algorithm, machine, T, initial_mu): 
    L = len(machine)
    counts = [0] * L
    listGains = initial_mu(L)
    opt_gain = np.zeros(T)
    gain = np.zeros(T)
    best_machine = np.argmax(machine)
    for i in range(T):
        levier = algorithm(listGains, counts)
        gain[i] = jouer(machine, levier)
        counts[levier] += 1
        listGains[levier] = (listGains[levier]*counts[levier] + gain[i])/(counts[levier]+1)
        opt_gain[i] = jouer(machine, best_machine)
    regret = opt_gain - gain
    cum_regret = np.cumsum(regret)
    cum_gain = np.cumsum(gain)    
    
def bernoulli(u_i):
    return np.random.uniform() < u_i

def generate_bernoulli_params(N,max_prop=1.):
    params = np.zeros(N)
    params[0] = np.random.uniform()
    params[1:] = np.random.uniform(high=params[0] * max_prop, size=N-1)
    np.random.shuffle(params)
    return params

def initial_mu_zeros(N):
    return np.zeros(N)

def initial_mu_random(N):
    return np.random.uniform(size=N)
        
"""
Bernoulli 
                regret
génération u_i
UCB
"""
