#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt

import tictactoe_etu as ttt
import utils as ut

games = [ttt.MorpionState, ttt.Puissance4State]
players = [ttt.RandomPlayer, ttt.MonteCarloPlayer, ttt.UCTPlayer]

class ExitException(Exception):
    pass

class GoBackException(Exception):
    pass

def menu(title, choices):
    """
    TODO
    """
    print(f'\n============================== {title} ==============================')
    for i in range(len(choices)):
        print(f'{i+1}. {choices[i]}')
    print('==================================================================')
    try:
        ch = input('Enter your choice (press ''q'' to exit): ')
        return int(ch) - 1
    except ValueError:
        if ch == 'q':
            raise ExitException
        print(f'Please enter a choice between 1 and {1 + len(choices)}')
        menu(title, choices)
    
def visualise_game():
    try:
        game = games[menu('Game', ['Tic-tac-toe', 'Connect Four'])]()
    except ExitException:
        raise GoBackException
    
    p1_ch = menu('1st player', ['Random player', 'Monte Carlo player', 'Upper confidence tree player'])
    args = []
    if p1_ch != 0:
        try:
            args.append( int(input('How many simulations per action? ')) )
        except:
            raise GoBackException
    player1 = players[p1_ch](*args)
    
    p2_ch = menu('2st player', ['Random player', 'Monte Carlo player', 'Upper confidence tree player'])
    args = []
    if p2_ch != 0:
        try:
            args.append( int(input('How many simulations per action? ')) )
        except:
            raise GoBackException
    player2 = players[p2_ch](*args)
    
    verbose = input('Do you wish to print the log (y/n)? ')
    if verbose == 'y' or verbose == 'yes': verbose = True
    else: verbose = False
    
    winner, log = ttt.Jeu(game, player1, player2).run(draw=True)
    if verbose:
        print(log)
        
def main():
    choices = [visualise_game]
    while True:
        try:
            ch = menu('MAIN', ['Visualise a game', 'others'])
            choices[ch]()
        except GoBackException:
            pass
        except ExitException:
            break

xs = np.arange(100, 2001,10)
nb_iter = 50
res = []
for N in xs:
    winner = 0
    for _ in range(nb_iter):
        #J1 = MonteCarloPlayer(N)
        J1 = ttt.UCTPlayer(N)
        #J2 = MonteCarloPlayer(N)
        #J2 = UCTPlayer(N)
        J2 = ttt.RandomPlayer()
        winner += ttt.Jeu(ttt.MorpionState(),J1,J2).run()[0]
    res.append(winner/nb_iter)
ys = np.array(res)
#ys = np.empty_like(res)
#for i in range(len(res)):
#    sub = res[:i+1]
#    ys[i] = sum(sub) / len(sub)
print(xs)
print(ys)
ut.plot('N', 'gain cumule', ys, xs)
#----------------------------------------------------TESTS -----------------------------------------------------
def histogram(N,nbIter):
    plt.rcdefaults()
    fig, ax = plt.subplots()
    players = np.array(['Random Player','MonteCarlo Player','Draws'])
    performance = np.arange(len(players))
    for i in range(nbIter):
        J1 = ttt.RandomPlayer()
        J2 = ttt.MonteCarloPlayer(N)
        winner = ttt.Jeu(ttt.MorpionState(),J1,J2).run(draw = False)[0]
        if(winner == 1):
            performance[0]+=1
        elif(winner == -1):
            performance[1]+=1
        else:
            performance[2]+=1
    xs = [i + 0.2   for i, _ in enumerate(players)]
    plt.bar(xs, performance)
    plt.ylabel("Number of won games")
    plt.xticks([i + 0.2 for i, _ in enumerate(players)], players)
    plt.show()

def simulate_MonteCarloVsRand(nb_iter,N):
    mean1 = np.zeros(nb_iter)
    mean2 = np.zeros(nb_iter)
    draw = np.zeros(nb_iter)
    xs = np.arange(nb_iter)
    J1 = ttt.MonteCarloPlayer(N)
    J2 = ttt.MonteCarloPlayer(N)
    winner1 = 0
    winner2 = 0
    draws = 0
    for i in range(1,nb_iter):
        w = ttt.Jeu(ttt.MorpionState(),J1,J2).run()[0]
        if(w == 1):
            winner1+=1
        elif(w == -1):
            winner2+=1
        else:
            draws+=1
        mean1[i] = float(winner1)/i
        mean2[i] = float(winner2)/i
        draw[i] = float(draws)/i
    plt.plot(xs,mean1,'g-',label = 'MonteCarlo Player 1')
    plt.plot(xs,mean2,'r-',label = 'MonteCarlo Player 2')
    plt.plot(xs,draw,'b-',label = 'Draws')
    plt.legend(["MonteCarlo Player 1", "MonteCarlo Player 2 ", "Draws"])
    plt.show()

def simulate_RandVsRand(nb_Iter):
    mean1 = np.zeros(nb_Iter)
    mean2 = np.zeros(nb_Iter)
    xs = np.arange(nb_Iter)
    J1 = ttt.RandomPlayer()
    J2 = ttt.RandomPlayer()
    winner1 = 0
    winner2 = 0
    for i in range(1,nb_Iter):
        w = ttt.Jeu(ttt.MorpionState(),J1,J2).run()[0]
        setValues(w, winner1, winner2)
        mean1[i] = float(winner1)/i
        mean2[i] = float(winner2)/i
    plt.plot(xs,mean1,'g-',label = 'Random Player')
    plt.plot(xs,mean2,'r-',label = 'Random Player')

    plt.legend(["Random Player 1", "Random Player 2"])
    plt.show()

"""xs = np.arange(10, 50,5)
nb_iter = 50
res = []
for N in xs:
    winner = 0
    for _ in range(nb_iter):
        J1 = MonteCarloPlayer(N)
        J2 = MonteCarloPlayer(N)
        winner += Jeu(MorpionState(),J1,J2).run()[0]
    res.append(winner/nb_iter)
ys = np.array(res)
ys = np.empty_like(res)
for i in range(len(res)):
    sub = res[:i+1]
    ys[i] = sum(sub) / len(sub)
#print(xs)
#print(ys)
plot('N', 'gain cumule', ys, xs)"""
"""def main():
    simulate_MonteCarloVsRand(1000,20)
if __name__ == "__main__":
    main()"""
